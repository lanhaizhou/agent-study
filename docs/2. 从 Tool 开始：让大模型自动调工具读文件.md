# 从 Tool 开始：让大模型自动调工具读文件 - 总结

对应代码：`chapter/2/tool-test/src/tool-file-read.mjs`（环境变量由同目录下 `loadEnv.mjs` 在首行 import 加载）。

---

## 一、为什么需要 Tool

- 普通聊天里大模型只能「告诉你怎么做」，不能替你执行（读写文件、执行命令等）。
- Cursor 能直接创建项目、写文件、装依赖、跑起来，是因为给 Agent 开发了 **Tool**，由模型在对话中决定何时调用。
- 常见 Tool：读文件、写文件、读目录、建目录、执行命令等。本节以「读文件」为例入门。

## 二、准备工作

**1. 大模型与 API**

- 示例用阿里千问（登录有免费 token 额度），其他模型同理。调用时需：`modelName`、`apiKey`、`baseURL`（见下方）。

**在百炼控制台获取并设置 API Key：**

1. 打开 [阿里云百炼控制台 - API 密钥](https://bailian.console.aliyun.com/cn-beijing/?tab=api#/api)（需先登录阿里云账号）。
2. 在「API-KEY 管理」或「API 密钥」页中，点击「创建 API-KEY」或使用已有密钥。
3. 创建后复制生成的 **API Key**（形如 `sk-xxx`），妥善保存；若泄露可在控制台删除该 Key 后重新创建。
4. 在项目根目录的 `.env` 中设置：
   - `OPENAI_API_KEY=你复制的 API Key`
   - `OPENAI_BASE_URL=https://dashscope.aliyuncs.com/compatible-mode/v1`（千问兼容 OpenAI 的接口地址）
   - `MODEL_NAME=qwen-coder-turbo`（编码场景可选用该模型；控制台「模型广场」中也可查看其他模型名称）。
5. 代码中通过根目录的 **loadEnv.mjs** 在入口首行 `import "./loadEnv.mjs"` 加载上述变量，不要将 API Key 写死在源码里。

**2. 项目与依赖**

- 根目录或子项目需安装：`@langchain/openai`、`@langchain/core`、`dotenv`、`zod`（见 `chapter/2/tool-test/package.json`）。
- `.env` 放在**仓库根目录**，由 `loadEnv.mjs` 按 monorepo 根路径加载，与 hello-langchain 等入口共用。
- 将 `.env` 加入 **.gitignore**，私密信息不提交 Git。

## 三、代码结构概览（与 tool-file-read.mjs 对应）

| 文档小节     | 代码位置 / 含义 |
| ------------ | ----------------- |
| 大模型配置   | `ChatOpenAI` 使用 `process.env.MODEL_NAME/OPENAI_API_KEY/OPENAI_BASE_URL`，`temperature: 0`。 |
| projectRoot  | `path.resolve(path.dirname(fileURLToPath(import.meta.url)), "..")`，即本脚本所在项目根 `chapter/2/tool-test`，供 read_file 解析相对路径。 |
| 定义工具     | `tool( 执行函数, { name, description, schema } )`，见下方。 |
| 绑定工具     | `modelWithTools = model.bindTools(tools)`。 |
| 对话消息     | `messages` 数组：`SystemMessage` + `HumanMessage`。 |
| Tool 循环    | `while (response.tool_calls?.length > 0)` 内执行工具、拼 `ToolMessage`、追加后再次 `invoke`。 |

## 四、开发 read_file Tool

- 使用 LangChain 的 **tool( 执行函数, 元数据 )**（代码约 30~45 行）：
  - **执行函数**：接收 `{ filePath }`，先解析路径：若为绝对路径则直接用，否则用 **projectRoot** 拼成完整路径（`path.join(projectRoot, filePath)`），再 `fs.readFile(fullPath, "utf-8")`，返回 `文件内容:\n${content}`。这样无论从仓库根（如 `pnpm ch2:read`）还是从子目录运行，相对路径都能正确找到文件。
  - **元数据**：`name: "read_file"`，`description` 说明何时调用、参数含义，`schema: z.object({ filePath: z.string().describe("要读取的文件路径") })`，供模型生成合规的 tool_calls。
- 用 **model.bindTools(tools)** 把工具绑到模型，模型在回复时可能返回 **tool_calls**（含 `name`、`args`、`id`），而不是直接给最终答案。

## 五、四种 Message（代码中的使用方式）

| 类型             | 含义 | 在代码中的用法 |
| ---------------- | ---- | -------------- |
| **SystemMessage** | 设定 AI 身份、能力、行为规范。 | `new SystemMessage(...)` 描述「代码助手、可用 read_file、工作流程 1/2/3」。 |
| **HumanMessage**  | 用户输入。 | `new HumanMessage("请读取 src/tool-file-read.mjs 文件内容并解释代码")`。 |
| **AIMessage**     | 模型回复；若决定调工具，会带 `tool_calls` 数组。 | 即 `response`，循环中通过 `response.tool_calls` 判断并执行工具。 |
| **ToolMessage**   | 工具执行结果，回传给模型；需带 **tool_call_id** 与对应 tool call 的 `id` 关联。 | `new ToolMessage({ content: String(result), tool_call_id: tc.id })`，每个 `tc` 对应一个 ToolMessage。 |

## 六、Tool 调用循环（与代码一致）

1. **首次调用**：`let response = await modelWithTools.invoke(messages)`；此时 `response` 可能是「带 tool_calls 的 AIMessage」。
2. **循环条件**：`while (response.tool_calls?.length > 0)`。
3. **循环体内**：
   - 遍历 `response.tool_calls`，用 `tools.find((t) => t.name === tc.name)` 找到工具，`await fn.invoke(tc.args)` 执行；
   - 将每个结果构造成 `ToolMessage`，`content` 为工具返回值，`tool_call_id` 为 `tc.id`；
   - `messages.push(response)`，再 `messages.push(...toolMessages)`；
   - `response = await modelWithTools.invoke(messages)`，进入下一轮。
4. **退出循环后**：`response` 不再包含 tool_calls，`response.content` 即为最终文字回答，可 `console.log(response.content)`。

这样模型完成「先返回 tool_calls → 执行 read_file → 回传 ToolMessage → 再基于文件内容生成解释」。

## 七、运行方式

- 从仓库根目录：`pnpm ch2:read`（会执行 `node chapter/2/tool-test/src/tool-file-read.mjs`，cwd 为根目录；read_file 内用 projectRoot 解析相对路径，故 `src/tool-file-read.mjs` 等相对路径仍正确）。
- 从子项目目录：`cd chapter/2/tool-test && node src/tool-file-read.mjs`（或 `pnpm run dev` 若已配置为运行该文件）。

## 八、总结

- **环境**：根目录 `.env` + `loadEnv.mjs` 统一加载；**.gitignore** 忽略 .env。
- **Tool**：执行函数（含 projectRoot 解析路径）+ name/description/schema（zod）；**model.bindTools(tools)** 后模型可返回 tool_calls。
- **消息**：System（设定）、Human（用户）、AI（含 tool_calls）、Tool（工具结果，带 tool_call_id）。
- **循环**：检测 tool_calls → 执行工具 → 追加 AIMessage + ToolMessage → 再 invoke，直到无 tool_calls，输出 content。据此可扩展写文件、执行命令等，向「简易版 Cursor」迈进。
