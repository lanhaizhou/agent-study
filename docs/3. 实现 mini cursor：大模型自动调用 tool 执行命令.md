# 实现 mini cursor：大模型自动调用 tool 执行命令 - 总结

对应代码：`chapter/3/tool-test/src/` 下的 `all-tools.mjs`、`mini-cursor.mjs`、`node-exec.mjs`。环境变量由根目录 `.env` + `import 'dotenv/config'` 加载。

---

## 一、目标与思路

- 上节已扩展 **read_file** tool；若再扩展执行命令、写文件、读/建目录等，即可实现「简易版 Cursor」：根据 prompt 创建项目、改代码、安装依赖、启动服务，全程由大模型自动调用 tool。
- 本节在 `tool-test` 项目上继续写，不新建项目。

## 二、Node 中执行命令

- 使用内置模块 **child_process** 的 **spawn**。
- 可指定 **cwd**（工作目录）、**stdio: 'inherit'**（子进程输出到当前控制台）、**shell: true**。
- 命令字符串用空格拆成 `cmd` 与 `args` 传入 `spawn`。
- 对有交互的脚手架（如 create-vite），用管道自动输入选项，例如：`echo -e "n\nn" | pnpm create vite react-todo-app --template react-ts`，避免卡在交互。

## 三、四个 Tool（all-tools.mjs）

| 工具 | 作用 | 要点 |
|------|------|------|
| **read_file** | 读取文件 | 路径 + 错误处理，返回「文件内容:\n${content}」 |
| **write_file** | 写入文件 | 自动 `fs.mkdir(dir, { recursive: true })` 创建父目录 |
| **execute_command** | 执行系统命令 | 支持 **workingDirectory**；返回结果中附带「请用 workingDirectory，不要用 cd」的提示 |
| **list_directory** | 列出目录 | 返回「目录内容:\n- 项1\n- 项2」 |

- 每个 tool 使用 LangChain 的 **tool( 执行函数, { name, description, schema } )**，参数用 **zod** 声明。
- **execute_command** 内用 `spawn`，在 `workingDirectory || process.cwd()` 下执行；成功时在返回文案中强调：后续在同一目录执行命令必须传 **workingDirectory**，不要在 **command** 里写 `cd`，避免模型重复 cd 导致路径错误。

## 四、execute_command 使用规则（System 中需写明）

- **workingDirectory** 已在工具内部完成「切换目录」，command 中不应再写 `cd`。
- 错误示例：`{ command: "cd react-todo-app && pnpm install", workingDirectory: "react-todo-app" }`。
- 正确示例：`{ command: "pnpm install", workingDirectory: "react-todo-app" }`。
- 在 SystemMessage 里明确写出上述规则，便于模型生成正确的 tool_calls。

## 五、Mini Cursor 主流程（mini-cursor.mjs）

| 步骤 | 说明 |
|------|------|
| 模型配置 | ChatOpenAI（如 qwen-plus），`temperature: 0`，`model.bindTools(tools)` 绑定四个工具 |
| 初始消息 | SystemMessage：当前工作目录、四个工具的名称与用途、execute_command 的 workingDirectory/cd 规则；HumanMessage：用户任务描述 |
| 循环（最多 maxIterations 轮） | 1）`modelWithTools.invoke(messages)`；2）若无 tool_calls 则输出 response.content 并结束；3）若有 tool_calls，逐个执行工具，将结果封装为 **ToolMessage**（带 tool_call_id）追加到 messages，再 invoke |

- 与 doc2 的 Tool 调用循环一致：检测 tool_calls → 执行工具 → 追加 AIMessage + ToolMessage → 再 invoke，直到无 tool_calls。

## 六、运行与示例

- 运行：在 `chapter/3/tool-test` 下执行 `node ./src/mini-cursor.mjs`（或从仓库根配置脚本运行）。
- 示例 case：在 prompt 中要求「创建 React Todo 项目 → 改 App.tsx 实现完整 TodoList（增删改、筛选、持久化、样式、动画）→ 在项目目录 pnpm install → pnpm run dev」；模型会依次调用 list_directory、write_file、read_file、execute_command 等完成全流程。
- 可选：使用 chalk 对「正在等待 AI 思考」等输出加颜色（如 `chalk.bgGreen`）。

## 七、总结

- **技术点**：`child_process.spawn` 执行命令并支持 cwd；LangChain **tool** + zod + **bindTools**；**ToolMessage** 回传工具结果；SystemMessage 中约定 workingDirectory 与禁止 cd 的规则。
- **效果**：大模型可自动完成「创建项目 → 读写文件 → 安装依赖 → 启动服务」，实现简易版 Cursor 的部分能力。
- **目的**：理解 Cursor 类产品「Tool + LLM」的实现思路，并可在同一套循环上扩展更多 tool（如建目录、删文件等），做自己的自动化 Agent。
